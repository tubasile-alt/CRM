‚úÖ PROBLEMA
Voc√™ disse: ‚Äúfinalizo o atendimento, os dados salvam, mas o status da agenda n√£o muda automaticamente para ATENDIDO‚Äù.

Pelo seu c√≥digo, o BACK-END j√° muda o status:

    appointment.status = 'atendido'
    db.session.commit()

Ent√£o, quando ‚Äún√£o muda automaticamente‚Äù, geralmente √© porque:
1) A TELA (front-end) n√£o faz refresh/refetch da agenda depois do checkout, ent√£o continua mostrando o status antigo.
E/OU
2) Existe um BUG: a rota ‚Äúremover da espera‚Äù usa o mesmo check_out(), e isso marca como ‚Äúatendido‚Äù mesmo quando s√≥ era pra desfazer o check-in.

‚úÖ SOLU√á√ÉO COMPLETA (recomendada)
A) Separar ‚ÄúFINALIZAR ATENDIMENTO‚Äù (checkout) de ‚ÄúREMOVER DA ESPERA‚Äù (undo check-in)
B) Fazer o checkout retornar o status na resposta (pra tela poder atualizar na hora)

========================================================
A) PATCH 1 ‚Äî services/waiting_service.py
========================================================

1) MANTENHA o check_out() finalizando e marcando como atendido
2) ADICIONE um m√©todo novo undo_check_in() para ‚Äúremover da espera‚Äù sem marcar como atendido
3) RETORNE status no check_out() (para o front atualizar automaticamente)

üëâ Substitua o m√©todo check_out() e adicione o undo_check_in() assim:

----------------------------------------
# services/waiting_service.py
----------------------------------------

def check_out(self, appointment_id):
    """
    Realiza check-out de um paciente (FINALIZA atendimento)
    - Sai da espera
    - Marca status como 'atendido'
    """
    appointment = Appointment.query.get(appointment_id)
    if not appointment:
        raise ValueError("Agendamento n√£o encontrado")

    appointment.waiting = False
    appointment.status = 'atendido'  # min√∫sculo (consistente com 'agendado')

    # Calcular tempo de espera e registrar
    wait_time = None
    if appointment.checked_in_time:
        try:
            checked_in = appointment.checked_in_time
            if checked_in.tzinfo is None:
                checked_in = self.tz.localize(checked_in)

            now = datetime.now(self.tz)
            delta = now - checked_in
            wait_time = int(delta.total_seconds() / 60)

            if wait_time >= 0:
                appointment.total_waiting_minutes = wait_time
        except Exception as e:
            import logging
            logging.error(f"Erro ao calcular tempo de espera: {e}")
            wait_time = None

    db.session.commit()

    # ‚úÖ IMPORTANTE: retornar status pra UI atualizar imediatamente
    return {
        'id': appointment.id,
        'patient_name': appointment.patient.name if appointment.patient else "Desconhecido",
        'wait_time_minutes': wait_time,
        'waiting': False,
        'status': appointment.status
    }


def undo_check_in(self, appointment_id):
    """
    Remove paciente da lista de espera (DESFAZ check-in)
    - N√ÉO finaliza atendimento
    - N√ÉO marca como atendido
    """
    appointment = Appointment.query.get(appointment_id)
    if not appointment:
        raise ValueError("Agendamento n√£o encontrado")

    appointment.waiting = False
    appointment.checked_in_time = None
    appointment.total_waiting_minutes = None
    appointment.room = None

    # ‚ö†Ô∏è N√ÉO muda appointment.status aqui!
    db.session.commit()

    return {
        'id': appointment.id,
        'patient_name': appointment.patient.name if appointment.patient else "Desconhecido",
        'waiting': False,
        'status': appointment.status
    }


========================================================
B) PATCH 2 ‚Äî routes/waiting_room.py
========================================================

Agora a rota /api/remove (remover da espera) N√ÉO pode chamar check_out().
Ela deve chamar undo_check_in().

üëâ Troque seu endpoint remove_from_waiting por este:

----------------------------------------
# routes/waiting_room.py
----------------------------------------

@waiting_room_bp.route('/api/remove/<int:appointment_id>', methods=['POST'])
@login_required
def remove_from_waiting(appointment_id):
    """Remove paciente da lista de espera (desfazer check-in)"""
    try:
        result = waiting_service.undo_check_in(appointment_id)  # ‚úÖ AQUI MUDA
        return jsonify({'success': True, 'data': result})
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Erro ao remover da lista'}), 500


========================================================
C) O QUE FAZER NO FRONT-END (tela da agenda)
========================================================

Depois de chamar:
POST /espera/api/checkout/<appointment_id>

Voc√™ precisa:
- OU refazer o GET da agenda (refetch)
- OU atualizar o item na lista usando a resposta.

Como agora o back-end retorna:
data.status = "atendido"

voc√™ pode fazer algo assim no JS (exemplo gen√©rico):

1) Ap√≥s o checkout:
- Pegue response.data.data.status
- Atualize o item na lista da agenda com o mesmo id

Exemplo (pseudo-c√≥digo):
- const res = await fetch('/espera/api/checkout/123', { method: 'POST' })
- const json = await res.json()
- se (json.success) ent√£o:
    - atualize o appointment de id json.data.id para status json.data.status
    - ou chame a fun√ß√£o que recarrega a agenda

========================================================
D) TESTE R√ÅPIDO
========================================================

1) Fa√ßa checkout do paciente
2) Confira no banco/endpoint de listagem de appointments se o status virou 'atendido'
3) Se no banco virou e na tela n√£o ‚Üí √© 100% refresh no front.
   (com o retorno status no checkout, normalmente resolve)

FIM ‚úÖ
